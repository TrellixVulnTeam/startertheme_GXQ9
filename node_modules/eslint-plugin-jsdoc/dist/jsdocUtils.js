"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _WarnSettings = _interopRequireDefault(require("./WarnSettings"));

var _getDefaultTagStructureForMode = _interopRequireDefault(require("./getDefaultTagStructureForMode"));

var _tagNames = require("./tagNames");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let tagStructure;

const setTagStructure = mode => {
  tagStructure = (0, _getDefaultTagStructureForMode.default)(mode);
}; // Given a nested array of property names, reduce them to a single array,
// appending the name of the root element along the way if present.


const flattenRoots = (params, root = '') => {
  let hasRestElement = false;
  let hasPropertyRest = false;
  const rests = [];
  const names = params.reduce((acc, cur) => {
    if (Array.isArray(cur)) {
      let nms;

      if (Array.isArray(cur[1])) {
        nms = cur[1];
      } else {
        if (cur[1].hasRestElement) {
          hasRestElement = true;
        }

        if (cur[1].hasPropertyRest) {
          hasPropertyRest = true;
        }

        nms = cur[1].names;
      }

      const flattened = flattenRoots(nms, root ? `${root}.${cur[0]}` : cur[0]);

      if (flattened.hasRestElement) {
        hasRestElement = true;
      }

      if (flattened.hasPropertyRest) {
        hasPropertyRest = true;
      }

      const inner = [root ? `${root}.${cur[0]}` : cur[0], ...flattened.names].filter(Boolean);
      rests.push(false, ...flattened.rests);
      return acc.concat(inner);
    }

    if (typeof cur === 'object') {
      if (cur.isRestProperty) {
        hasPropertyRest = true;
        rests.push(true);
      } else {
        rests.push(false);
      }

      if (cur.restElement) {
        hasRestElement = true;
      }

      acc.push(root ? `${root}.${cur.name}` : cur.name);
    } else if (typeof cur !== 'undefined') {
      rests.push(false);
      acc.push(root ? `${root}.${cur}` : cur);
    }

    return acc;
  }, []);
  return {
    hasPropertyRest,
    hasRestElement,
    names,
    rests
  };
};

const getPropertiesFromPropertySignature = propSignature => {
  if (propSignature.type === 'TSIndexSignature' || propSignature.type === 'TSConstructSignatureDeclaration' || propSignature.type === 'TSCallSignatureDeclaration') {
    return undefined;
  }

  if (propSignature.typeAnnotation && propSignature.typeAnnotation.typeAnnotation.type === 'TSTypeLiteral') {
    return [propSignature.key.name, propSignature.typeAnnotation.typeAnnotation.members.map(member => {
      return getPropertiesFromPropertySignature(member);
    })];
  }

  return propSignature.key.name;
};

const getFunctionParameterNames = (functionNode, checkDefaultObjects) => {
  // eslint-disable-next-line complexity
  const getParamName = (param, isProperty) => {
    var _param$left, _param$left3;

    if (_lodash.default.has(param, 'typeAnnotation') || _lodash.default.has(param, 'left.typeAnnotation')) {
      const typeAnnotation = _lodash.default.has(param, 'left.typeAnnotation') ? param.left.typeAnnotation : param.typeAnnotation;

      if (typeAnnotation.typeAnnotation.type === 'TSTypeLiteral') {
        const propertyNames = typeAnnotation.typeAnnotation.members.map(member => {
          return getPropertiesFromPropertySignature(member);
        });
        const flattened = { ...flattenRoots(propertyNames),
          annotationParamName: param.name
        };

        if (_lodash.default.has(param, 'name') || _lodash.default.has(param, 'left.name')) {
          return [_lodash.default.has(param, 'left.name') ? param.left.name : param.name, flattened];
        }

        return [undefined, flattened];
      }
    }

    if (_lodash.default.has(param, 'name')) {
      return param.name;
    }

    if (_lodash.default.has(param, 'left.name')) {
      return param.left.name;
    }

    if (param.type === 'ObjectPattern' || ((_param$left = param.left) === null || _param$left === void 0 ? void 0 : _param$left.type) === 'ObjectPattern') {
      var _param$left2;

      const properties = param.properties || ((_param$left2 = param.left) === null || _param$left2 === void 0 ? void 0 : _param$left2.properties);
      const roots = properties.map(prop => {
        return getParamName(prop, true);
      });
      return [undefined, flattenRoots(roots)];
    }

    if (param.type === 'Property') {
      switch (param.value.type) {
        case 'ArrayPattern':
          return [param.key.name, param.value.elements.map((prop, idx) => {
            return {
              name: idx,
              restElement: prop.type === 'RestElement'
            };
          })];

        case 'ObjectPattern':
          return [param.key.name, param.value.properties.map(prop => {
            return getParamName(prop, isProperty);
          })];

        case 'AssignmentPattern':
          {
            switch (param.value.left.type) {
              case 'Identifier':
                // Default parameter
                if (checkDefaultObjects && param.value.right.type === 'ObjectExpression') {
                  return [param.key.name, param.value.right.properties.map(prop => {
                    return getParamName(prop, isProperty);
                  })];
                }

                break;

              case 'ObjectPattern':
                return [param.key.name, param.value.left.properties.map(prop => {
                  return getParamName(prop, isProperty);
                })];

              case 'ArrayPattern':
                return [param.key.name, param.value.left.elements.map((prop, idx) => {
                  return {
                    name: idx,
                    restElement: prop.type === 'RestElement'
                  };
                })];
            }
          }
      }

      switch (param.key.type) {
        case 'Identifier':
          return param.key.name;
        // The key of an object could also be a string or number

        case 'Literal':
          return param.key.raw || // istanbul ignore next -- `raw` may not be present in all parsers
          param.key.value;
        // case 'MemberExpression':

        default:
          // Todo: We should really create a structure (and a corresponding
          //   option analogous to `checkRestProperty`) which allows for
          //   (and optionally requires) dynamic properties to have a single
          //   line of documentation
          return undefined;
      }
    }

    if (param.type === 'ArrayPattern' || ((_param$left3 = param.left) === null || _param$left3 === void 0 ? void 0 : _param$left3.type) === 'ArrayPattern') {
      var _param$left4;

      const elements = param.elements || ((_param$left4 = param.left) === null || _param$left4 === void 0 ? void 0 : _param$left4.elements);
      const roots = elements.map((prop, idx) => {
        return {
          name: `"${idx}"`,
          restElement: (prop === null || prop === void 0 ? void 0 : prop.type) === 'RestElement'
        };
      });
      return [undefined, flattenRoots(roots)];
    }

    if (['RestElement', 'ExperimentalRestProperty'].includes(param.type)) {
      return {
        isRestProperty: isProperty,
        name: param.argument.name,
        restElement: true
      };
    }

    if (param.type === 'TSParameterProperty') {
      return getParamName(param.parameter, true);
    }

    throw new Error(`Unsupported function signature format: \`${param.type}\`.`);
  };

  return (functionNode.params || functionNode.value.params).map(param => {
    return getParamName(param);
  });
};

const hasParams = functionNode => {
  // Should also check `functionNode.value.params` if supporting `MethodDefinition`
  return functionNode.params.length;
};
/**
 * Gets all names of the target type, including those that refer to a path, e.g.
 * "@param foo; @param foo.bar".
 */


const getJsdocTagsDeep = (jsdoc, targetTagName) => {
  const ret = [];
  jsdoc.tags.forEach(({
    name,
    tag,
    type
  }, idx) => {
    if (tag !== targetTagName) {
      return;
    }

    ret.push({
      idx,
      name,
      type
    });
  });
  return ret;
};

const modeWarnSettings = (0, _WarnSettings.default)();

const getTagNamesForMode = (mode, context) => {
  switch (mode) {
    case 'jsdoc':
      return _tagNames.jsdocTags;

    case 'typescript':
      return _tagNames.typeScriptTags;

    case 'closure':
    case 'permissive':
      return _tagNames.closureTags;

    default:
      if (!modeWarnSettings.hasBeenWarned(context, 'mode')) {
        context.report({
          loc: {
            start: {
              column: 1,
              line: 1
            }
          },
          message: `Unrecognized value \`${mode}\` for \`settings.jsdoc.mode\`.`
        });
        modeWarnSettings.markSettingAsWarned(context, 'mode');
      } // We'll avoid breaking too many other rules


      return _tagNames.jsdocTags;
  }
};

const getPreferredTagName = (context, mode, name, tagPreference = {}) => {
  var _Object$entries$find;

  const prefValues = Object.values(tagPreference);

  if (prefValues.includes(name) || prefValues.some(prefVal => {
    return prefVal && typeof prefVal === 'object' && prefVal.replacement === name;
  })) {
    return name;
  } // Allow keys to have a 'tag ' prefix to avoid upstream bug in ESLint
  // that disallows keys that conflict with Object.prototype,
  // e.g. 'tag constructor' for 'constructor':
  // https://github.com/eslint/eslint/issues/13289
  // https://github.com/gajus/eslint-plugin-jsdoc/issues/537


  const tagPreferenceFixed = _lodash.default.mapKeys(tagPreference, (_value, key) => {
    return key.replace('tag ', '');
  });

  if (_lodash.default.has(tagPreferenceFixed, name)) {
    return tagPreferenceFixed[name];
  }

  const tagNames = getTagNamesForMode(mode, context);
  const preferredTagName = (_Object$entries$find = Object.entries